[
  {
    "question": "Which command correctly creates a new Backstage application?",
    "choices": [
      "npm create backstage-app",
      "npx @backstage/create-app",
      "yarn create backstage-app",
      "backstage init new-app"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "The official command to create a new Backstage app is `npx @backstage/create-app`, which sets up the initial project structure with all necessary dependencies."
  },
  {
    "question": "In a Backstage project, which directory contains the frontend code?",
    "choices": ["packages/frontend", "frontend", "src/app", "packages/app"],
    "correct": 3,
    "section": "Backstage Development Workflow",
    "explanation": "In a Backstage project, the frontend application code is located in the `packages/app` directory, following the monorepo structure."
  },
  {
    "question": "Which command starts only the backend service during local development?",
    "choices": [
      "yarn backend",
      "yarn run:backend",
      "yarn start-backend",
      "yarn server"
    ],
    "correct": 2,
    "section": "Backstage Development Workflow",
    "explanation": "The command to start only the backend service during local development is `yarn start-backend`, leaving the frontend inactive."
  },
  {
    "question": "What file extension is used for Backstage configuration files?",
    "choices": [".yaml", ".json", ".js", ".config"],
    "correct": 0,
    "section": "Backstage Development Workflow",
    "explanation": "Backstage uses YAML (.yaml) files for configuration, with the primary configuration file being `app-config.yaml`."
  },
  {
    "question": "Which of the following statements about the Backstage project structure is true?",
    "choices": [
      "The project uses a monolithic structure with all code in a single package",
      "Each plugin requires its own Git repository",
      "Backstage uses a microservices architecture with separate repositories for each service",
      "The project follows a monorepo structure with packages in the 'packages' directory"
    ],
    "correct": 3,
    "section": "Backstage Development Workflow",
    "explanation": "Backstage uses a monorepo structure, with different packages such as 'app' and 'backend' organized under the 'packages' directory."
  },
  {
    "question": "Which command adds a new dependency to a specific package in a Backstage project?",
    "choices": [
      "yarn add react-router --package app",
      "yarn workspace @internal/my-plugin add react-router",
      "npm install react-router --save-to=my-plugin",
      "yarn package-add my-plugin react-router"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "To add a dependency to a specific package in a Backstage project, you use Yarn workspaces with the package name as shown."
  },
  {
    "question": "What is the recommended approach for running a Backstage application in Docker?",
    "choices": [
      "Single-stage build with a Node.js base image",
      "Multi-stage build separating build and runtime environments",
      "Using an official Backstage Docker image",
      "Building directly on an Alpine Linux base image"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "The recommended approach for Docker builds is using multi-stage builds to separate the build environment from the runtime environment, resulting in smaller and more secure containers."
  },
  {
    "question": "When applying TypeScript configuration in a Backstage plugin, what is the typical base configuration extended?",
    "choices": [
      "@typescript/recommended",
      "@backstage/cli/config/tsconfig.json",
      "@backstage/core/tsconfig.json",
      "../../tsconfig.json"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "The typical TypeScript configuration for Backstage plugins extends from `@backstage/cli/config/tsconfig.json`, which provides standardized settings."
  },
  {
    "question": "What command compiles a Backstage project without starting the development server?",
    "choices": ["yarn tsc", "yarn compile", "yarn build", "yarn make"],
    "correct": 2,
    "section": "Backstage Development Workflow",
    "explanation": "The `yarn build` command compiles the Backstage project without starting the development server, creating a production-ready build."
  },
  {
    "question": "Which approach is used to override configuration values for different environments in Backstage?",
    "choices": [
      "Creating `app-config.${NODE_ENV}.yaml` files",
      "Modifying the `config/environments` directory",
      "Using a `.env` file with environment-specific variables",
      "Directly editing the main configuration for each deployment"
    ],
    "correct": 0,
    "section": "Backstage Development Workflow",
    "explanation": "Backstage uses environment-specific configuration files named `app-config.${NODE_ENV}.yaml` to override values for different environments, such as development, production, or testing."
  },
  {
    "question": "What is the primary purpose of the Backstage Catalog?",
    "choices": [
      "Managing infrastructure deployments",
      "Storing documentation",
      "Providing a centralized inventory of software and resources",
      "Monitoring system health"
    ],
    "correct": 2,
    "section": "Backstage Catalog",
    "explanation": "The primary purpose of the Backstage Catalog is to provide a centralized inventory of software, infrastructure, documentation, and other resources."
  },
  {
    "question": "Which field is required in all Backstage catalog entity definitions?",
    "choices": [
      "spec.owner",
      "metadata.description",
      "metadata.name",
      "spec.type"
    ],
    "correct": 2,
    "section": "Backstage Catalog",
    "explanation": "The `metadata.name` field is required in all Backstage catalog entity definitions as it provides the unique identifier for the entity."
  },
  {
    "question": "What file format is used for entity definitions in the Backstage Catalog?",
    "choices": ["JSON", "XML", "YAML", "TOML"],
    "correct": 2,
    "section": "Backstage Catalog",
    "explanation": "Entity definitions in the Backstage Catalog use YAML format for structured data representation."
  },
  {
    "question": "Which annotation would you use to connect a catalog component to its GitHub repository?",
    "choices": [
      "github.com/project-path",
      "github.com/repo-url",
      "github.com/project-slug",
      "backstage.io/github-url"
    ],
    "correct": 2,
    "section": "Backstage Catalog",
    "explanation": "The `github.com/project-slug` annotation is used to connect a catalog component to its GitHub repository, typically in the format `organization/repo-name`."
  },
  {
    "question": "How can you add a TechDocs connection to an entity in the catalog?",
    "choices": [
      "By setting `spec.docs.enabled: true`",
      "By adding an annotation `backstage.io/techdocs-ref: dir:.`",
      "By creating a separate `docs.yaml` file",
      "By adding a `documentation` field to `spec`"
    ],
    "correct": 1,
    "section": "Backstage Catalog",
    "explanation": "The `backstage.io/techdocs-ref: dir:.` annotation is used to indicate that TechDocs documentation exists in the same directory as the entity."
  },
  {
    "question": "What is a common reason for entity ingestion failures in the Backstage Catalog?",
    "choices": [
      "Database connectivity issues",
      "YAML syntax errors in entity definitions",
      "Network latency",
      "Missing plugin dependencies"
    ],
    "correct": 1,
    "section": "Backstage Catalog",
    "explanation": "A common reason for entity ingestion failures is YAML syntax errors in entity definition files, including incorrect indentation or invalid fields."
  },
  {
    "question": "Which API endpoint can be used to validate an entity definition without registering it?",
    "choices": [
      "POST /api/catalog/validate",
      "GET /api/catalog/check",
      "POST /api/entities/validate",
      "GET /api/backstage/validate-entity"
    ],
    "correct": 0,
    "section": "Backstage Catalog",
    "explanation": "The endpoint for validating an entity definition without registering it is `POST /api/catalog/validate`."
  },
  {
    "question": "What relationship field would you use to indicate that a Component entity depends on an API entity?",
    "choices": [
      "spec.dependencies",
      "spec.consumesApis",
      "spec.api-dependencies",
      "spec.requires"
    ],
    "correct": 1,
    "section": "Backstage Catalog",
    "explanation": "The `spec.consumesApis` field is used to indicate that a Component entity depends on API entities, establishing a formal relationship."
  },
  {
    "question": "Which of the following would you configure to refresh catalog locations on a schedule?",
    "choices": [
      "catalog:\n  refresh:\n    interval: 60",
      "catalog:\n  cron: \"*/30 * * * *\"",
      "catalog:\n  locations:\n    - schedule:\n        frequency: { minutes: 30 }",
      "catalog:\n  processingInterval: 30"
    ],
    "correct": 2,
    "section": "Backstage Catalog",
    "explanation": "This configuration sets up scheduled refreshes for catalog locations, with a frequency of every 30 minutes."
  },
  {
    "question": "Which of the following best describes Backstage's architecture?",
    "choices": [
      "A monolithic application with embedded plugins",
      "A client-server architecture with plugin-based frontend and backend",
      "A serverless architecture running on cloud functions",
      "A microservices-based application with each plugin as an independent service"
    ],
    "correct": 1,
    "section": "Backstage Infrastructure",
    "explanation": "Backstage follows a client-server architecture with a React-based frontend and Node.js backend, both of which use a plugin system for extensibility."
  },
  {
    "question": "What statement best describes the Backstage client-server architecture?",
    "choices": [
      "The frontend and backend are completely isolated and communicate solely through REST APIs",
      "A React-based frontend communicates with a Node.js backend through HTTP, both sharing a plugin system that maps frontend plugins to backend plugins",
      "The frontend is a thin client that only renders data, while the backend contains all business logic",
      "Each plugin has its own dedicated frontend and backend microservice that operate independently"
    ],
    "correct": 1,
    "section": "Backstage Infrastructure",
    "explanation": "Backstage uses a React frontend and Node.js backend that communicate over HTTP. The plugin system is shared between frontend and backend, with frontend plugins often having corresponding backend plugins that provide necessary APIs and services."
  },
  {
    "question": "What is the recommended database for a production Backstage deployment?",
    "choices": ["SQLite", "MongoDB", "PostgreSQL", "MySQL"],
    "correct": 2,
    "section": "Backstage Infrastructure",
    "explanation": "PostgreSQL is the recommended database for production Backstage deployments due to its reliability, feature set, and compatibility."
  },
  {
    "question": "Which of the following is NOT a core backend plugin in Backstage?",
    "choices": ["catalog", "scaffolder", "kubernetes", "techdocs"],
    "correct": 2,
    "section": "Backstage Infrastructure",
    "explanation": "While the kubernetes plugin is commonly used, it is not one of the core backend plugins like catalog, scaffolder, or techdocs."
  },
  {
    "question": "What is the minimum recommended setup for running Backstage in a production Kubernetes environment?",
    "choices": [
      "A single pod with the Backstage application",
      "Separate deployments for frontend and backend with a shared database",
      "Independent microservices for each plugin",
      "A StatefulSet for the backend and a Deployment for the frontend"
    ],
    "correct": 1,
    "section": "Backstage Infrastructure",
    "explanation": "The recommended production setup includes separate deployments for frontend and backend components, sharing a common database."
  },
  {
    "question": "Which environment variable substitution format is used in Backstage configuration files?",
    "choices": ["{{ENV_VAR}}", "$ENV_VAR", "${ENV_VAR}", "%ENV_VAR%"],
    "correct": 2,
    "section": "Backstage Infrastructure",
    "explanation": "Backstage uses the `${ENV_VAR}` format for environment variable substitution in its configuration files."
  },
  {
    "question": "What configuration is necessary to enable CORS in the Backstage backend?",
    "choices": [
      "backend:\n  cors:\n    enabled: true",
      "backend:\n  cors:\n    origin: https://example.com\n    methods: [GET, POST, PUT, DELETE]",
      "server:\n  cors:\n    allowedOrigins: ['https://example.com']",
      "http:\n  cors:\n    - origin: https://example.com\n      methods: '*'"
    ],
    "correct": 1,
    "section": "Backstage Infrastructure",
    "explanation": "This configuration correctly enables CORS in the Backstage backend, specifying allowed origins and methods."
  },
  {
    "question": "In a Kubernetes deployment, how would you typically manage Backstage configuration?",
    "choices": [
      "As environment variables in the Deployment manifest",
      "Using a ConfigMap mounted as a volume",
      "Using a Secret for the entire configuration",
      "Embedding it directly in the container image"
    ],
    "correct": 1,
    "section": "Backstage Infrastructure",
    "explanation": "In a Kubernetes deployment, Backstage configuration is typically managed using a ConfigMap mounted as a volume to the pods."
  },
  {
    "question": "What is the purpose of the 'discovery' service in Backstage's backend architecture?",
    "choices": [
      "To discover new plugins",
      "To find and catalog services in your infrastructure",
      "To locate internal service URLs in the Backstage backend",
      "To enable service mesh features"
    ],
    "correct": 2,
    "section": "Backstage Infrastructure",
    "explanation": "The 'discovery' service helps backend plugins locate and communicate with other services within the Backstage backend."
  },
  {
    "question": "How do you create a new frontend plugin in Backstage?",
    "choices": [
      "yarn add --plugin frontend my-plugin",
      "backstage create-plugin my-plugin",
      "yarn new --select plugin",
      "yarn add @backstage/plugin-generator"
    ],
    "correct": 2,
    "section": "Customizing Backstage",
    "explanation": "To create a new frontend plugin, you use the `yarn new --select plugin` command, which runs the plugin creation wizard."
  },
  {
    "question": "Which command creates a new backend plugin?",
    "choices": [
      "yarn new --select backend-plugin",
      "yarn create-backend-plugin",
      "backstage add backend-plugin",
      "yarn plugin --backend"
    ],
    "correct": 0,
    "section": "Customizing Backstage",
    "explanation": "The command to create a new backend plugin is `yarn new --select backend-plugin`."
  },
  {
    "question": "What is the difference between frontend and backend plugins in Backstage?",
    "choices": [
      "Frontend plugins are written in JavaScript, backend plugins in TypeScript",
      "Frontend plugins handle UI components while backend plugins provide API endpoints",
      "Frontend plugins run in the browser while backend plugins run in separate containers",
      "Frontend plugins are configured in app-config.yaml, backend plugins in plugins.yaml"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "The main difference is that frontend plugins handle UI components and user interaction, while backend plugins provide API endpoints and integrate with external services."
  },
  {
    "question": "How do you share functionality between different components, both frontend and backend?",
    "choices": [
      "By using global variables shared between frontend and backend",
      "By using common libraries in a shared package that can be imported by both frontend and backend components",
      "By configuring shared functions in app-config.yaml",
      "By replicating code between frontend and backend components"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "Shared functionality in Backstage is typically implemented in common libraries that are packaged separately and imported where needed, allowing code reuse between frontend and backend components."
  },
  {
    "question": "Which Docker command is used to build a Backstage image?",
    "choices": [
      "docker-compose up",
      "docker build .",
      "docker run -p 7007:7007",
      "docker pull backstage"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "'docker build .' builds a Docker image from the Dockerfile in the current directory. For Backstage, you can also use 'yarn build-image --tag backstage:1.0.0'."
  },
  {
    "question": "How can you customize the default Backstage layout?",
    "choices": [
      "By modifying the app-config.yaml file",
      "By overriding React components in App.tsx",
      "By creating new backend plugins",
      "By editing routes.ts in the backend"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "Customize the layout by overriding React components in App.tsx. This defines frontend structure and routes, while app-config.yaml handles configuration."
  },
  {
    "question": "When creating a new Backstage plugin, which command initializes the plugin structure?",
    "choices": [
      "backstage-cli new",
      "npm plugin-init",
      "yarn plugin-init",
      "npm create-plugin"
    ],
    "correct": 0,
    "section": "Customizing Backstage",
    "explanation": "'backstage-cli new' initializes a new Backstage plugin structure, scaffolding the necessary files and directories following plugin architecture conventions."
  },
  {
    "question": "What type of file is typically used to specify dependencies for Backstage backend plugins?",
    "choices": [
      "package.json",
      "app-config.yaml",
      "Dockerfile",
      "backend-config.yaml"
    ],
    "correct": 0,
    "section": "Customizing Backstage",
    "explanation": "package.json specifies dependencies for Backstage backend plugins, containing npm/yarn dependencies. app-config.yaml is for runtime configuration, not dependencies."
  },
  {
    "question": "What are the purposes of running a Backstage project locally?",
    "choices": [
      "To debug deployment issues",
      "To test custom plugins",
      "To update global dependencies",
      "To troubleshoot global configurations"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "Running locally allows testing custom plugins during development, validating functionality and debugging before deployment."
  },
  {
    "question": "What is a key difference between frontend and backend plugins in Backstage?",
    "choices": [
      "Frontend plugins manage API integrations, while backend plugins manage UI components.",
      "Frontend plugins handle user interfaces, while backend plugins manage server-side logic.",
      "Backend plugins are required for CI/CD integration, while frontend plugins handle entity ingestion.",
      "Backend plugins render UI components dynamically, while frontend plugins are static."
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "Frontend plugins handle UI components and user interaction, while backend plugins manage server-side logic like APIs and integrations."
  },
  {
    "question": "What is the primary configuration file used to customize Backstage behavior?",
    "choices": [
      "backstage.json",
      "app-config.yaml",
      "package.json",
      "config.ts"
    ],
    "correct": 1,
    "section": "Backstage infrastructure",
    "explanation": "app-config.yaml is the primary configuration file containing settings for the app, backend, integrations, plugins, and core functionality."
  },
  {
    "question": "Which command is used to validate your Backstage configuration schema?",
    "choices": [
      "backstage-cli config:validate",
      "backstage-cli config:check",
      "yarn config:test",
      "npm run validate-config"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "'backstage-cli config:check' validates configuration schema, ensuring app-config.yaml conforms to expected format and identifying errors."
  },
  {
    "question": "What is the default database client used by Backstage for plugin storage?",
    "choices": ["MySQL", "PostgreSQL", "better-sqlite3", "MongoDB"],
    "correct": 2,
    "section": "Backstage Infrastructure",
    "explanation": "Backstage uses better-sqlite3 as the default database client for development. PostgreSQL is recommended for production deployments."
  },
  {
    "question": "Which file specifies the configuration schema for a Backstage plugin?",
    "choices": ["schema.json", "config.d.ts", "plugin.yaml", "manifest.json"],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "config.d.ts specifies the configuration schema for a plugin, defining expected structure and types referenced in package.json."
  },
  {
    "question": "What is TechDocs in Backstage primarily used for?",
    "choices": [
      "Managing software dependencies",
      "Generating and serving technical documentation",
      "Monitoring application health",
      "Creating scaffolder templates"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "TechDocs generates and serves technical documentation using MkDocs, publishing to various storage backends like S3, Google Cloud Storage, or local filesystem."
  },
  {
    "question": "Which storage backend is NOT supported by TechDocs?",
    "choices": [
      "AWS S3",
      "Google Cloud Storage",
      "Azure Blob Storage",
      "MongoDB GridFS"
    ],
    "correct": 3,
    "section": "Customizing Backstage",
    "explanation": "TechDocs supports AWS S3, Google Cloud Storage, Azure Blob Storage, and local filesystem, but not MongoDB GridFS."
  },
  {
    "question": "What annotation is used to connect a catalog entity to its TechDocs?",
    "choices": [
      "backstage.io/docs-ref",
      "backstage.io/techdocs-ref",
      "techdocs.io/path",
      "docs.backstage.io/location"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "'backstage.io/techdocs-ref: dir:.' indicates TechDocs documentation exists, typically in the same directory as catalog-info.yaml."
  },
  {
    "question": "What is the Scaffolder in Backstage used for?",
    "choices": [
      "Building Docker containers",
      "Creating new software projects from templates",
      "Managing user permissions",
      "Monitoring system metrics"
    ],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "The Scaffolder creates new software projects from predefined templates, ensuring consistency and automating setup tasks across teams."
  },
  {
    "question": "Which file format is used for Scaffolder templates?",
    "choices": ["JSON", "XML", "YAML", "TOML"],
    "correct": 2,
    "section": "Backstage Development Workflow",
    "explanation": "Scaffolder templates use YAML format with API version 'scaffolder.backstage.io/v1beta3', defining parameters, steps, and metadata."
  },
  {
    "question": "What is the purpose of the 'integrations' section in app-config.yaml?",
    "choices": [
      "Configuring database connections",
      "Setting up authentication with external services like GitHub, GitLab",
      "Defining plugin dependencies",
      "Managing user roles and permissions"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "The 'integrations' section configures authentication for external services like GitHub, GitLab, and Azure DevOps, enabling data fetching and interaction."
  },
  {
    "question": "Which authentication provider is NOT natively supported by Backstage?",
    "choices": ["GitHub OAuth", "Google OAuth", "LDAP", "Slack OAuth"],
    "correct": 3,
    "section": "Customizing Backstage",
    "explanation": "Backstage supports GitHub OAuth, Google OAuth, and LDAP, but not Slack OAuth. It focuses on development-focused identity providers."
  },
  {
    "question": "What is the default port that Backstage backend runs on during development?",
    "choices": ["3000", "7007", "8080", "5000"],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "Backstage backend runs on port 7007 by default, configured in app-config.yaml under backend.listen.port."
  },
  {
    "question": "How do you register a new location in the Backstage Catalog?",
    "choices": [
      "Only through the app-config.yaml file",
      "Only through the UI",
      "Both through app-config.yaml and the UI",
      "Only programmatically via API calls"
    ],
    "correct": 2,
    "section": "Backstage Catalog",
    "explanation": "Catalog locations can be registered through app-config.yaml (permanent) and the UI (ad-hoc), plus programmatically via API."
  },
  {
    "question": "What is the purpose of the Software Templates feature in Backstage?",
    "choices": [
      "Creating reusable UI components",
      "Generating standardized software projects and components",
      "Managing container orchestration",
      "Building CI/CD pipelines"
    ],
    "correct": 1,
    "section": "Customizing Backstage",
    "explanation": "Software Templates provide self-service project bootstrapping with best practices, proper structure, and necessary configuration built-in."
  },
  {
    "question": "Which command is used to start both frontend and backend in development mode?",
    "choices": ["yarn start", "yarn dev", "yarn run:all", "yarn develop"],
    "correct": 1,
    "section": "Backstage Development Workflow",
    "explanation": "'yarn dev' starts both frontend and backend services in development mode with hot reloading for a complete development environment."
  },
  {
    "question": "What is the role of the Discovery API in Backstage?",
    "choices": [
      "Finding new plugins in the marketplace",
      "Locating internal service URLs within the Backstage backend",
      "Discovering entities in the catalog",
      "Auto-detecting configuration files"
    ],
    "correct": 1,
    "section": "Backstage Infrastructure",
    "explanation": "The Discovery API helps backend plugins locate and communicate with other services by resolving service URLs dynamically."
  }
]
